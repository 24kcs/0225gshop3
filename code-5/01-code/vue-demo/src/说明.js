/**
 * main.js中Vue实例多次,浏览器中vue插件,就可以看到多个root
 * data为什么是函数,而不是对象
 * 多个组件同时共用一个data,如果是对象,只能执行一次,但是如果是函数可以多次执行调用,但是返回不同对象
 * 正向代理,反向代理
 * 正向代理:隐藏客户端(翻墙)
 * 客户端请求--->proxy(中间件)针对服务器隐藏的客户端--->服务器
 * 反向代理:隐藏真实服务端(proxy代理的是服务器)
 * 客户端请求--->proxy(中间件)请求空闲多(压力小)的服务器--->服务器(多个服务器)
 * 
 * 
 *  1.插槽:
 *  1)普通插槽：普通插槽,没有名字,直接传值即可
 *  2)具名插槽: 有名字,传值的时候,需要使用名字的标识,其他的内容不能传过去
 *  3)作用域插槽: 把子组件中插槽要使用的数据传入到了父级组件中,父级组件就可以控制子级组件中插槽的数据的显示方式
 *  2.Vue中的混合
 * 
 * 
 *  3. 事件:
 *  Vue中事件分类:
 *  1) 原生事件:在普通的标签上直接使用DOM的事件(DOM中自带的事件名字),
 *    在组件标签上使用DOM事件之后,加上一个.native修饰符
 * 
 *  如果是组件使用了事件,一定要在该事件后面使用.native修饰符,此时这个事件才是真正的原生事件,此时在该组件内容中最外面的包裹的这个标签上会添加这个事件,
 * 如果是原生事件,只要有回调函数,事件触发后,回调函数中的代码必然会执行
 * 
 *  2) 自定义事件:
 *   1)首先这个事件的名字是自己定义的(无论是普通标签还是组件标签)
 *   2)如果在组件标签上使用的是DOM自带的事件或者是自定义的事件(没有.native修饰)
 * 
 * 如果是自定义事件,虽然有回调函数,但是只要没有手动的分发,该事件的回调函数中的代码是不会执行
 * 
 * 
 * 4. 双向数据绑定
 *  原理: 获取当前文本框的value值,重新赋值给表达式,但是需要配合input事件
 * input :value="msg" @input="msg=fsdffsfsfsfsd"
 *  <p>{{msg}}</p>
 * 
 *  组件中使用v-model(明确:实际上里面有@input事件----此时该事件是自定义事件,)获取文本框的值,改变v-model="msg"msg这个表达式的值-----必须要进行分发---什么时候分发?组件中的input标签的input事件触发的时候,就会使用$emit()方法对传过来的自定义input事件进行分发,同时把我当前文本的值也传过去
 * 
 * 
 * 
 * 
 */